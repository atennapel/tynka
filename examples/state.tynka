def VTy = Ty Val

data Unit := MkUnit

data Bool := False | True

data Pair A B := MkPair A B

def fst {A B} (p : Pair A B) : A = p.1

def unpair {A B C : VTy} (p : Pair A B) (f : A -> B -> C) : C =
  match p | MkPair a b. f a b

def Int = Foreign "I"
def (+) a b = foreign Int "op:96" a b
def (-) a b = foreign Int "op:100" a b
def (<=) a b = foreign Bool "branch:158" a b

-- State monad
def State (S A : VTy) = S -> Pair S A

def runState {S A} (c : State S A) (s : S) : Pair S A = c s
def execState {S A} (c : State S A) (s : S) : A = (c s).2

def get {S} : State S S = \s. (s, s)
def put {S : VTy} (s : S) : State S Unit = \_. (s, [])
def update {S : VTy} (f : S -> S) : State S Unit = \s. (f s, [])

def return {S A : VTy} (a : A) : State S A = \s. (s, a) 

def (<$>) {S A B : VTy} (f : A -> B) (c : State S A) : State S B =
  \s. match c s | MkPair s' res. (s', f res)

def (>>=) {S A B : VTy} (c : State S A) (f : A -> State S B) : State S B =
  \s. unpair (c s) \s' res. f res s'

def (>>) {S A B : VTy} (c : State S A) (f : State S B) : State S B =
  \s. f (c s).1

-- example
def FibState = Pair Int Int

def fibStep (st : FibState) : FibState =
  match st | MkPair x1 x2. (x2, x1 + x2)

def fibState (n : Int) : State FibState Int =
  fix (rec n.
    if n <= 0 then
      fst <$> get
    else
      update fibStep >> rec (n - 1)
  ) n

def fib (n : Int) : Int := execState (fibState n) (0, 1)

def main := fib 8
