def VTy = Ty Val

data Unit := MkUnit

data Pair A B := MkPair A B

def fst {A B} (p : Pair A B) : A = p.1

def unpair {A B C : VTy} (p : Pair A B) (f : A -> B -> C) : C =
  match p | MkPair a b. f a b

data Nat := Z | S Nat

def (+) (a b : Nat) : Nat :=
  fix (rec a. \acc. match a
  | Z. acc
  | S n. rec n (S acc)) a b

-- State monad
def State (S A : VTy) = S -> Pair S A

def runState {S A} (c : State S A) (s : S) : Pair S A = c s
def execState {S A} (c : State S A) (s : S) : A = (c s).2

def get {S} : State S S = \s. (s, s)
def put {S : VTy} (s : S) : State S Unit = \_. (s, [])
def update {S : VTy} (f : S -> S) : State S Unit = \s. (f s, [])

def return {S A : VTy} (a : A) : State S A = \s. (s, a) 

def (<$>) {S A B : VTy} (f : A -> B) (c : State S A) : State S B =
  \s. match c s | MkPair s' res. (s', f res)

def (>>=) {S A B : VTy} (c : State S A) (f : A -> State S B) : State S B =
  \s. unpair (c s) \s' res. f res s'

def (>>) {S A B : VTy} (c : State S A) (f : State S B) : State S B =
  \s. f (c s).1

-- example
def FibState = Pair Nat Nat

def fibStep (st : FibState) : FibState =
  match st | MkPair x1 x2. (x2, x1 + x2)

def fibState (n : Nat) : State FibState Nat =
  fix (rec n. match n
  | Z. fst <$> get
  | S m. update fibStep >> rec m
  ) n

def fib (n : Nat) : Nat := execState (fibState n) (Z, S Z)

def main := fib (S (S (S (S (S Z)))))
