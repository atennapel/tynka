-- booleans
def CBool = (A : Meta) -> A -> A -> A
def CTrue : CBool = \A t f. t
def CFalse : CBool = \A t f. f

def cond {A} (b : CBool) (t : A) (f : A) : A = b A t f

def (!) b = cond b CFalse CTrue
def (&&) a b = cond a b CFalse
def (||) a b = cond a CTrue b

-- natural numbers
def Nat = (A : Meta) -> A -> (A -> A) -> A
def Z : Nat = \A z s. z
def S (n : Nat) : Nat = \A z s. s (n A z s)

def foldNat {A} (n : Nat) (z : A) (s : A -> A) : A = n A z s

def (+) a b = foldNat a b S

def test = (S Z) + (S (S Z))

-- lists
def CList A = (R : Meta) -> R -> (A -> R -> R) -> R
def CNil {A} : CList A = \R n c. n
def CCons {A} (hd : A) (tl : CList A) : CList A = \R n c. c hd (tl R n c)

def foldr {A R} (n : R) (c : A -> R -> R) (l : CList A) : R = l R n c

def map {A B} (f : A -> B) (l : CList A) : CList B =
  foldr CNil (\hd tl. CCons (f hd) tl) l

def test2 = map ((+) (S Z)) (CCons (S Z) (CCons (S (S Z)) (CCons (S (S (S Z))) CNil)))

-- identity
def (~) {A} (x y : A) = (P : A -> Meta) -> P x -> P y
def Refl {A} {x : A} : x ~ x = \P x. x

def rewrite {A x y} (P : A -> Meta) (p : x ~ y) (x : P x) : P y = p P x

def p1 : (S Z) + (S (S Z)) ~ (S (S (S Z))) = Refl
def p2 : !CTrue ~ CFalse = Refl

-- unit
def UnitType = (A : Meta) -> A -> A
def Unit : UnitType = \A x. x

-- sigma module
def NatS =
  (Nat : Meta) **
  (Z : Nat) **
  (S : Nat -> Nat) **
  (fold : {A} (n : Nat) (z : A) (s : A -> A) -> A) **
  UnitType
def NatM : NatS = (Nat, Z, S, foldNat, Unit)

def addM (m : NatS) (a : m.Nat) (b : m.Nat) : m.Nat =
  m.fold a b m.S

def testM = addM NatM (S Z) (S (S Z))
