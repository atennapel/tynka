def (!) b = if b then False else True
def (&&) a b = if a then b else False
def (||) a b = if a then True else b

def (+) a b = primIntAdd a b
def (*) a b = primIntMul a b
def (-) a b = primIntSub a b
def (/) a b = primIntDiv a b
def (%) a b = primIntMod a b

def (==) a b = primIntEq a b
def (!=) a b = primIntNeq a b

def (<) a b = primIntLt a b
def (>) a b = primIntGt a b
def (<=) a b = primIntLeq a b
def (>=) a b = primIntGeq a b

def Nat = (A : Meta) -> A -> (A -> A) -> A
def Z : Nat = \A z s. z
def S (n : Nat) : Nat = \A z s. s (n A z s)

def foldNat {A} (n : Nat) (z : A) (s : A -> A) : A = n A z s

def pow (a : Nat) (b : Int) : Int = foldNat a 1 (\r. r * b)

def fac (n : Int) : Int :=
  fix (go n.
    if n < 2 then 1
    else n * (go (n - 1))) n

def facTR (n : Int) : Int :=
  fix (go n. \acc.
    if n < 2 then acc
    else go (n - 1) (acc * n)) n 1

def foldInt {A : VTy} (n : Int) (z : A) (s : Int -> A -> A) : A =
  fix (go n. \acc.
    if n <= 0 then acc
    else go (n - 1) (s n acc)) n z

def facTR2 (n : Int) : Int := foldInt n 1 (\n r. n * r)

def test := \n. pow (S (S (S Z))) n

def head {A} (l : List A) (d : A) =
  caseList l d (\hd _. hd)

def xxx := head #[1, 2, 3] 0

def map {A B : VTy} (f : A -> B) (l : List A) : List B =
  fix (go l. caseList l Nil (\hd tl. f hd :: go tl)) l

def testmap := map ((+) 1) #[1, 2, 3]
