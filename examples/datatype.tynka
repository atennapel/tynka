def VTy = Ty Val

data Void

data Unit := MkUnit

data Bool := False | True

def cond {cv : CV} {A : Ty cv} (a b : A) (c : Bool) : A =
  if c then a else b

def (!) b = if b then False else True
def (&&) a b = if a then b else False
def (||) a b = if a then True else b

data Pair A B := MkPair A B

def fst {A B : VTy} (p : Pair A B) : A = p.1
def snd {A B : VTy} (p : Pair A B) : B = p.2

data Either A B := Left A | Right B

data Maybe A := Nothing | Just A

-- natural numbers
data Nat := Z | S Nat

def (+) a b :=
  fix (rec a. \acc. match a
  | Z. acc
  | S n. rec n (S acc)) a b

-- lists
data List A
  | Nil
  | (::) A (List A)

def isEmpty {A : VTy} (l : List A) : Bool =
  match l
  | Nil. True
  | _. False

def head {A : VTy} (d : A) (l : List A) : A =
  match l
  | Nil. d
  | (::) hd _. hd

def foldr {A : VTy} {cv : CV} {B : Ty cv} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. match l
  | Nil. n
  | (::) hd tl. c hd (go tl)
  ) l

def foldl {A B : VTy} (n : B) (c : B -> A -> B) (l : List A) : B =
  foldr (\acc. acc) (\hd go acc. go (c acc hd)) l n

def map {A B : VTy} (f : A -> B) (l : List A) : List B =
  foldr Nil (\hd tl. f hd :: tl) l

def length {A : VTy} (l : List A) : Nat =
  foldl 0 (\n _. S n) l

def (++) {A : VTy} (a b : List A) : List A = foldr b (::) a

def sum = foldl 0 (+)
