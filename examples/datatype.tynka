def VTy = Ty Val

data Void

data Unit := MkUnit

data Bool := False | True

def if {A : VTy} (c : Bool) (a b : A) : A =
  match c
  | True. a
  | False. b

data Pair A B := MkPair A B

def fst {A B : VTy} (p : Pair A B) : A =
  match p
  | MkPair fst snd. fst

def snd {A B : VTy} (p : Pair A B) : B =
  match p
  | MkPair fst snd. snd

data Either A B := Left A | Right B

data Maybe A := Nothing | Just A

-- natural numbers
data Nat := Z | S Nat

def (+) (a b : Nat) : Nat :=
  fix (rec a. \acc. match a
  | Z. acc
  | S n. rec n (S acc)) a b

-- lists
data List A
  | Nil
  | (::) A (List A)

def isEmpty {A : VTy} (l : List A) : Bool =
  match l
  | Nil. True
  | _. False

def head {A : VTy} (d : A) (l : List A) : A =
  match l
  | Nil. d
  | (::) hd _. hd

def foldr {A : VTy} {cv} {B : Ty cv} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. match l
  | Nil. n
  | (::) hd tl. c hd (go tl)
  ) l

def foldl {A B : VTy} (n : B) (c : B -> A -> B) (l : List A) : B =
  foldr (\acc. acc) (\hd go acc. go (c acc hd)) l n

def map {A B : VTy} (f : A -> B) (l : List A) : List B =
  foldr Nil (\hd tl. f hd :: tl) l

def length {A : VTy} (l : List A) : Nat =
  foldl 0 (\n _. S n) l

def (++) {A : VTy} (a b : List A) : List A = foldr b (::) a

def sum = foldl 0 (+)
