def VTy = Ty Val

data Unit := MkUnit
data Bool := False | True

def Int = Foreign "I"
def (+) a b = foreign Int "op:96" a b
def (-) a b = foreign Int "op:100" a b
def (*) a b = foreign Int "op:104" a b
def (<=) a b = foreign Bool "branch:158" a b

-- lists
data List A
  | Nil
  | (::) A (List A)

def foldr {A : VTy} {cv} {B : Ty cv} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. match l
  | Nil. n
  | (::) hd tl. c hd (go tl)
  ) l

-- push lists
def Push A = (cv : CV) (B : Ty cv) -> (A -> B -> B) -> B -> B

def Push/cons {A : VTy} (hd : A) (tl : Push A) : Push A =
  \cv B c n. c hd (tl cv B c n)

def Push/fromList {A : VTy} (as : List A) : Push A =
  \cv B f b. foldr b f as

def Push/toList {A : VTy} (as : Push A) : List A = as _ _ (::) Nil

def Push/map {A B : VTy} (f : A -> B) (as : Push A) : Push B =
  \cv R c n. as cv R (\a bs. c (f a) bs) n

def Push/foldr {A : VTy} {cv} {B : Ty cv} (b : B) (f : A -> B -> B) (as : Push A) : B =
  as cv B f b

def Push/foldl {A B : VTy} (b : B) (f : B -> A -> B) (as : Push A) : B =
  as _ (B -> B) (\a rec acc. rec (f acc a)) (\acc. acc) b

def (>>=) = bindIO
def (>>>) {A B : VTy} (a : IO A) (b : IO B) : IO B = a >>= \_. b
def Push/foldIO_ {A : VTy} (f : A -> IO Unit) (as : Push A) : IO Unit =
  Push/foldr (returnIO MkUnit) (\hd tl. f hd >>> tl) as

def Push/sum = Push/foldl 0 (+)
def Push/product = Push/foldl 1 (*)

def Push/range (n : Int) : Push Int =
  \cv B f b. fix (go c. if c <= 0 then b else f c (go (c - 1))) n

def main := Push/product (Push/range 10)
