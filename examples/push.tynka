def Val = Ty V

def foldr {A : Val} {vf : VF} {B : Ty vf} (cons : A -> B -> B) (nil : B) (l : List A) : B =
  fix (go l. caseList l nil (\hd tl. cons hd (go tl))) l

def Push A = (vf : VF) (B : Ty vf) -> (A -> B -> B) -> B -> B

def up {A : Val} (as : List A) : Push A = \vf B f b. foldr f b as

def down {A : Val} (as : Push A) = as _ _ (::) Nil

def map {A B : Val} (f : A -> B) (as : Push A) : Push B =
  \vf R c n. as vf R (\a bs. c (f a) bs) n

def foldl {A B : Val} (f : B -> A -> B) (b : B) (as : Push A) : B =
  as _ (B -> B) (\a rec acc. rec (f acc a)) (\acc. acc) b

def (+) a b = primIntAdd a b
def (*) a b = primIntMul a b
def (-) a b = primIntSub a b

def sum = foldl (\x y. x + y) 0

def list := #[1, 2, 3]

def (|>) {A B} (x : A) (f : A -> B) : B = f x

def main : Int -> Int := \_.
  up list
  |> map (\x. x + 1)
  |> map (\x. let y := x; y * y)
  |> map (\x. x - 1)
  |> sum
