def caseListTy {A : VTy} {B : Ty} : (l : List A) (n : B) (c : A -> List A -> B) -> B =
  elimTy (\B. (l : List A) (n : B) (c : A -> List A -> B) -> B)
    (\_ l n c. caseList l n c)
    (\X _ rec l n c. \x. rec l (n x) (\hd tl. c hd tl x))
    B

def foldr {A : VTy} {B : Ty} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. caseListTy l n (\hd tl. c hd (go tl))) l

def Push A = (B : Ty) -> (A -> B -> B) -> B -> B

def up {A : VTy} (as : List A) : Push A = \B f b. foldr b f as

def down {A : VTy} (as : Push A) = as (List A) (::) Nil

def map {A B : VTy} (f : A -> B) (as : Push A) : Push B =
  \R c n. as R (\a bs. c (f a) bs) n

def foldl {A B : VTy} (f : B -> A -> B) (b : B) (as : Push A) : B =
  as (B -> B) (\a rec acc. rec (f acc a)) (\acc. acc) b

def (+) a b = primIntAdd a b
def (*) a b = primIntMul a b
def (-) a b = primIntSub a b

def sum = foldl (\x y. x + y) 0

def list := #[1, 2, 3]

def (|>) {A B} (x : A) (f : A -> B) : B = f x

def test :=
  up list
  |> map (\x. x + 1)
  |> map (\x. let y := x; y * y)
  |> map (\x. x - 1)
  |> sum
