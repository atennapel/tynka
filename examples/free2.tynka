import "lib/Prelude"
import "lib/Free"
import "lib/IO"

def (>>=) = Free/bind
def return = Free/return
def (+) a b = Int/add a b
def (<) a b = Int/lt a b

def StackF (K : Meta) =
  (cv : CV) (R : Ty cv) ->

    (Str -> (Void -> K) -> R) ->

    ((Int -> K) -> R) ->
    
    (Long -> K -> R) ->

    ((Int -> K) -> R) ->
    (Int -> K -> R) ->
    
    R

def StackF/handle {K : Meta} {cv : CV} {R : Ty cv}
  (throw : Str -> (Void -> K) -> R)
  (read : (Int -> K) -> R)
  (write : Long -> K -> R)
  (get : (Int -> K) -> R)
  (put : Int -> K -> R)
  (s : StackF K) : R =
  s _ R throw read write get put

def StackF/FunctorM : FunctorM StackF =
  \f x. \cv R throw read write get put.
    x _ R
      (\msg k. throw msg (\x. f (k x)))
      (\k. read (\x. f (k x)))
      (\w k. write w (f k))
      (\k. get (\x. f (k x)))
      (\s k. put s (f k))

def throw {A} (msg : Str) : Free StackF A =
  Free/lift StackF/FunctorM (\cv R throw read write get put. throw msg (\x. absurd x))
def read : Free StackF Int =
  Free/lift StackF/FunctorM (\cv R throw read write get put. read (\s. s))
def write (s : Long) : Free StackF Unit =
  Free/lift StackF/FunctorM (\cv R throw read write get put. write s U)
def get : Free StackF Int =
  Free/lift StackF/FunctorM (\cv R throw read write get put. get (\s. s))
def put (s : Int) : Free StackF Unit =
  Free/lift StackF/FunctorM (\cv R throw read write get put. put s U)

def M (A : VTy) = Int -> Long -> Int -> Either Str (Pair (Pair Int A) Long)

def M/return {A : VTy} (a : A) : M A = \r w s. Right (MkPair (MkPair s a) w)
def M/bind {A B : VTy} (c : M A) (f : A -> M B) : M B =
  \r w s.
    match c r w s
    | Left msg. Left msg
    | Right p. match p | MkPair st w'. match st | MkPair s' res.
      f res r w' s'

def M/throw {A : VTy} (msg : Str) : M A = \r w s. Left msg
def M/read : M Int = \r w s. Right (MkPair (MkPair s r) w)
def M/write (n : Long) : M Unit = \r w s. Right (MkPair (MkPair s U) (Long/add w n))
def M/get : M Int = \r w s. Right (MkPair (MkPair s s) w)
def M/put (s : Int) : M Unit = \r w _. Right (MkPair (MkPair s U) w)

def handle {A} (c : Free StackF A) : M A =
  Free/handle c (\x. M/return x) \. StackF/handle
    (\msg k. M/bind (M/throw msg) k)
    (\k. M/bind M/read k)
    (\x k. M/bind (M/write x) \_. k)
    (\k. M/bind M/get k)
    (\x k. M/bind (M/put x) \_. k)

def prog : Free StackF Int =
  Free/rec (do
    s <- get;
    put (s + 1);
    write (Long/fromInt s);
    r <- read;
    Free/return (MkPair s r)
  ) \p loop return. match p | MkPair s r.
    if s < r then
      loop
    else
      return s

def prog2 : Free StackF Int =
  Free/recLoop \loop done. do
    s <- get;
    put (s + 1);
    write (Long/fromInt s);
    r <- read;
    Free/return
      if s < r then
        loop
      else
        done s

def res := handle prog 100000 (Long/fromInt 0) 0

def main (_ : Array Str) :=
  match res
  | Left msg. putLn msg
  | Right p. match p | MkPair st w. match st | MkPair s a.
    do {IO/bind}
      putLn a;
      putLn w;
      putLn s
