def VTy = Ty Val

data Unit := U

data Bool := False | True
def (&&) a b = if a then b else False

def Int = Foreign "I"
def (+) a b = foreign Int "op:96" a b
def (==) a b = foreign Bool "branch:153" a b
def (>=) a b = foreign Bool "branch:156" a b
def (<=) a b = foreign Bool "branch:158" a b

data List A
  | Nil
  | (::) A (List A)

def reverse {A : VTy} (l : List A) : List A =
  fix (go l. \acc. match l
  | Nil. acc
  | (::) hd tl. go tl (hd :: acc)
  ) l Nil

-- parser combinators
-- translated from https://tgdwyer.github.io/parsercombinators/
def Char = Int
def String = List Char

data ParseError
  | UnexpectedEof
  | ExpectedEof String
  | UnexpectedChar Char
  | UnexpectedString String

data ParseResult A := Error ParseError | Result String A

def Parser (A : VTy) = String -> ParseResult A

def return {A : VTy} (a : A) : Parser A = \s. Result s a

def fail {A : VTy} (e : ParseError) : Parser A = \_. Error e

def ParseResult/map {A B : VTy} (f : A -> B) (p : ParseResult A) : ParseResult B =
  match p | Error e. Error e | Result s a. Result s (f a)

def (<$>) {A B : VTy} (f : A -> B) (p : Parser A) : Parser B =
  \s. ParseResult/map f (p s)

def (>>=) {A B : VTy} (p : Parser A) (f : A -> Parser B) : Parser B =
  \s. match p s | Error e. Error e | Result s a. f a s

def (>>) {A B : VTy} (p : Parser A) (k : Parser B) : Parser B =
  p >>= \_. k

def (<$$>) {A B C : VTy} (f : A -> B -> C) (p1 : Parser A) (p2 : Parser B) : Parser C =
  p1 >>= \a. p2 >>= \b. return (f a b)

def char : Parser Char =
  \s. match s | Nil. Error UnexpectedEof | (::) c s. Result s c

def satisfy (f : Char -> Bool) : Parser Char =
  char >>= \v.
    if f v then
      return v
    else
      fail (UnexpectedChar v)

def is (c : Char) : Parser Char = satisfy ((==) c)

def (<|>) {A : VTy} (p1 p2 : Parser A) : Parser A =
  \s. match p1 s
  | Error _. p2 s
  | Result s v. Result s v

def many {A : VTy} (p : Parser A) : Parser (List A) =
  reverse <$> \s. fix (go s. \acc.
    match p s
    | Error e. Result s acc
    | Result s' hd. go s' (hd :: acc)
    ) s Nil

def digit : Parser Char = satisfy \c. c >= 48 && c <= 57

def spaces : Parser Unit = (\_. U) <$> many (is 32)

def number : Parser (List Char) = many digit

def input := #[48, 49, 10]
def main := number input
