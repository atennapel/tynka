def id {A} (x : ^A) : A = x

def test (x y : Bool) := id x

def head {A : VTy} (d : A) (l : List A) : A =
  caseList l d (\hd _. hd)

def testhead := head 0 #[1, 2, 3]

def (+) a b = primIntAdd a b

def caseListTy {A : VTy} {B : Ty} : (l : List A) (n : B) (c : A -> List A -> B) -> B =
  elimTy (\B. (l : List A) (n : B) (c : A -> List A -> B) -> B)
    (\_ l n c. caseList l n c)
    (\X _ rec l n c. \x. rec l (n x) (\hd tl. c hd tl x))
    B

def (^*) : Ty -> Meta = elimTy (\_. Meta) (\A. A) (\A _ B. A -> B)

def caseListTyMeta {A : VTy} {B : Ty} : (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B =
  elimTy (\B. (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B)
    (\_ l n c. caseList l n c)
    (\_ _ rec l n c x. rec l (n x) (\hd tl. c hd tl x))
    B

def foldr {A : VTy} {B : Ty} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. caseListTy l n (\hd tl. c hd (go tl))) l

def foldl {A : VTy} {B : VTy} (n : B) (c : A -> B -> B) (l : List A) : B =
  foldr (\acc. acc) (\hd tl acc. tl (c hd acc)) l n

def sum : List Int -> Int := foldl 0 (+)

def foldrMeta {A : VTy} {B : Ty} : (n : ^*B) (c : A -> ^*B -> ^*B) (l : List A) -> ^*B =
  elimTy (\B. (n : ^*B) (c : A -> ^*B -> ^*B) (l : List A) -> ^*B)
    (\B n c l. fix (go l. caseList l n (\hd tl. c hd (go tl))) l)
    (\X B rec n c l x. rec (n x) (\hd tl. c hd (\_. tl) x) l)
    B

def foldlMeta {A : VTy} {B : VTy} (n : B) (c : A -> B -> B) (l : List A) : B =
  foldrMeta {B = B -> B} (\acc. acc) (\hd tl acc. tl (c hd acc)) l n

def sumMeta : List Int -> Int := foldl 0 (+)

def flet {A : Ty} {B : Ty} : A -> (A -> B) -> B =
  elimTy (\B. A -> (A -> B) -> B)
    (\_ v k. let x := v; k v)
    (\X B rec v k x. rec v (\a. k a x))
    B

def testflet : Int -> Int :=
  flet (1+1) \x.
  \y. y + x
