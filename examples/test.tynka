def id {A} (x : ^A) : A = x

def test (x y : Bool) := id x

def head {A : VTy} (d : A) (l : List A) : A =
  caseList l d (\hd _. hd)

def testhead := head 0 #[1, 2, 3]

def (+) a b = primIntAdd a b

def caseListTy {A : VTy} {B : Ty} : (l : List A) (n : B) (c : A -> List A -> B) -> B =
  elimTy (\B. (l : List A) (n : B) (c : A -> List A -> B) -> B)
    (\_ l n c. caseList l n c)
    (\X _ rec l n c. \x. rec l (n x) (\hd tl. c hd tl x))
    B

def (^*) : Ty -> Meta = elimTy (\_. Meta) (\A. A) (\A _ B. A -> B)

def caseListTyMeta {A : VTy} {B : Ty} : (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B =
  elimTy (\B. (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B)
    (\_ l n c. caseList l n c)
    (\_ _ rec l n c x. rec l (n x) (\hd tl. c hd tl x))
    B

def foldr {A : VTy} {B : Ty} (n : B) (c : A -> B -> B) (l : List A) : B =
  fix (go l. caseListTy l n (\hd tl. c hd (go tl))) l

def foldl {A : VTy} {B : VTy} (n : B) (c : A -> B -> B) (l : List A) : B =
  foldr (\acc. acc) (\hd tl acc. tl (c hd acc)) l n

def sum : List Int -> Int := foldl 0 (+)
