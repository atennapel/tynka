def id {A} (x : ^A) : A = x

def test (x y : Bool) := id x

def head {A : VTy} (d : A) (l : List A) : A =
  caseList l d (\hd _. hd)

def testhead := head 0 #[1, 2, 3]

def (+) a b = primIntAdd a b

def caseListTy {A : VTy} {B : Ty} : (l : List A) (n : B) (c : A -> List A -> B) -> B =
  elimTy (\B. (l : List A) (n : B) (c : A -> List A -> B) -> B)
    (\_ l n c. caseList l n c)
    (\X _ rec l n c. \x. rec l (n x) (\hd tl. c hd tl x))
    B

def testL (l : List Int) : Int :=
  let f : Int -> Int := caseListTy {Int} {Int -> Int} l (\x. x) (\hd tl x. x);
  f 0

def (^*) : Ty -> Meta = elimTy (\_. Meta) (\A. A) (\A _ B. A -> B)

def caseListTyMeta {A : VTy} {B : Ty} : (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B =
  elimTy (\B. (l : List A) (n : ^*B) (c : A -> List A -> ^*B) -> ^*B)
    (\_ l n c. caseList l n c)
    (\_ _ rec l n c x. rec l (n x) (\hd tl. c hd tl x))
    B

def testL2 (l : List Int) : Int :=
  let f : Int -> Int := caseListTyMeta {Int} {Int -> Int} l (\x. x) (\hd tl x. x);
  f 0

def foldr {A : VTy} {B : Ty} : ^*B -> (A -> ^*B -> ^*B) -> List A -> ^*B =
  elimTy (\B. ^*B -> (A -> ^*B -> ^*B) -> List A -> ^*B)
    (\_ n c l. caseListTyMeta {A} {B} )
    _f
    B

{-
def foldrR {A : VTy} {B : Ty} : ^*B -> (A -> ^*B -> ^*B) -> (List A -> ^*B) -> List A -> ^*B =
  elimTy (\B. ^*B -> (A -> ^*B -> ^*B) -> (List A -> ^*B) -> List A -> ^*B)
    (\B n c g l. caseList l n (\hd tl. c hd (g tl)))
    (\X B rec n c g l x. rec (n x) (\hd tl. c hd (\_. tl) x) (\l. g l x) l)
    B
def foldr {A : VTy} {B : Ty} (n : ^*B) (c : A -> ^*B -> ^*B) (l : List A) : ^*B =
  fix (go l. foldrR n c go l) l
-}
